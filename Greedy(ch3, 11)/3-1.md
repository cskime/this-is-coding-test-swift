# Greedy

- 현재 상황에서 가장 좋은 것을 고르는 알고리즘으로, 현재의 선택이 나중에 미칠 영향은 고려하지 않는다.
- 그리디 알고리즘 유형의 문제는 창의력, 즉 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구한다.
- 그리지 알고리즘은 항상 '최적의 해'를 찾는 것이 아니다. 먼저 해법을 고민해 보고, 그 해법이 정당한지 검토할 수 있어야 한다.

## 거스름돈 문제

```
거스름돈으로 500원, 100원, 50원, 10원짜리 동전이 무한히 존재한다.
거슬러 줘야 할 돈이 N원일 때, 거슬러 줘야 할 동전의 최소 개수를 구하라.
단, N은 항상 10의 배수이다.
```

### 풀이

- 그리디 알고리즘 유형의 문제는 '기준'을 제시해 준다. (e.g. '가장 큰 순서대로', '가장 작은 순서대로')
- 이 문제에서의 '기준'은 동전의 '최소 개수'를 구하는 것이므로, 이 기준으로부터 '가장 큰 단위부터 거슬러 주는 것'이라는 아이디어를 떠올릴 수 있다.

```swift
func solution(_ N: Int) -> Int {
    var N = N
    let coins = [500, 100, 50, 10]    // 큰 단위 화폐부터 계산하기 위해 array에 단위가 큰 순서대로 넣었다
    var count = 0

    for coin in coins {
        count += N / coin   // 해당 화폐로 거슬러 줄 수 있는 동전의 개수 세기
        N %= coin           // 해당 화폐를 사용한 개수 만큼의 금액을 뺀 남아있는 금액 계산	
    }

    return count
}
```

- 이 코드는 화폐의 개수(K) 만큼 반복문을 돌며 연산하므로, 시간 복잡도는 `O(K)`가 된다.
- 시간 복잡도에서 거스름돈 N은 표기하지 않았으므로, 이 알고리즘은 거슬러 줘야 하는 금액의 크기와는 무관하다는 것을 알 수 있다.
