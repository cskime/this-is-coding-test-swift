# 큰 수의 법칙

```
이 문제에서 큰 수의 법칙은 다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더해서 가장 큰 수를 만드는 방법이다.
단, 배열의 특정 인덱스에 해당하는 수가 연속해서 K번을 초과하여 더해질 수는 없다.
(조건 : 2 <= N < 1000, 1 <= M <= 10,000, 1 <= K <= 10,000)
```

## 풀이 1

- 가장 큰 수를 만들어야 하므로, 배열에서 가장 큰 수를 찾는다. -> Greedy
- K번까지만 더할 수 있으므로, 가장 큰 수를 K번 더하고 그 다음으로 큰 수를 1번 더한 뒤 다시 가장 큰 수를 K번 더한다.

```swift
func solution(_ n: Int, _ m: Int, _ k: Int, _ numbers: [Int]) -> Int{
    let sorted = numbers.sorted(by: >)    // 0: 가장 큰 수, 1: 두 번째로 큰 수
    var left = m
    var sum = 0
    
    while left > 0 {    // m번 연산
        for _ in 0..<k {    // 한 index의 수를 k번 연산
            sum += sorted[0]
            left -= 1
        }
        
        sum += sorted[1]
        left -= 1
    }
    
    return sum
}
```

- 이 코드는 M번을 반복하며 내부에서 K번 연산하므로, 시간복잡도는 `O(MK)`가 된다.
- M번 반복 연산 안에서 두 번째로 큰 수를 한번 더하는 연산은 K번 연산에 비해 아주 작으므로 무시할 수 있다.

## 풀이 2

- 가장 큰 수를 K번 더하는 횟수를 최대로 할 때 모든 합이 가장 커지므로, 가장 큰 수를 K번 더하고 두 번째로 큰 수를 1번 더하는 것을 반복한다.
- K가 3이라면, `{first, first, first, second}`와 같은 수열의 요소들을 반복적으로 더하는 과정이다. 즉, 반복되는 수열을 `K+1`번 더한다.
- 가장 큰 수는 수열이 더해지는 횟수(`M / (K+1)`)에 수열 안에서 더해지는 횟수(`K`)만큼 더해지므로, `(M / (K+1)) * K)`번 더해진다.
- 두 번째로 큰 수는 `M`이 수열의 개수로 나누어 떨어지는지에 따라 달라진다.
  - `M`이 수열의 개수로 나누어 떨어진다면, 두 번째로 큰 수는 수열의 개수 만큼 더해지므로 `M / (K+1)`번 더해진다.
  - `M`이 수열의 개수로 나누어 떨어지지 않는다면, 수열의 개수보다 1개 적게 더해지므로 `(M / (K+1)) - 1`번 더해진다.
  - 전체 더해지는 횟수 M번 중, 가장 큰 수를 더한 횟수를 제외한 나머지가 두 번째로 큰 수를 더하는 횟수가 된다.

```swift
func solution(_ n: Int, _ m: Int, _ k: Int, _ numbers: [Int]) -> Int{
    let sorted = numbers.sorted(by: >)
    let firstCount = (m / (k + 1)) * k
    let secondCount = (m - firstCount)
    return sorted[0] * firstCount + sorted[1] * secondCount
}
```
- 이 코드는 반복문 없이 한 번씩 연산하므로, 시간 복잡도는 `O(1)`이 된다.
